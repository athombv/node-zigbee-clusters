// Auto-generated TypeScript definitions for zigbee-clusters
// Generated by scripts/generate-types.js

import * as EventEmitter from "events";

type EndpointDescriptor = {
  endpointId: number;
  inputClusters: number[];
  outputClusters: number[];
};

type ConstructorOptions = {
  endpointDescriptors: EndpointDescriptor[];
  sendFrame: (endpointId: number, clusterId: number, frame: Buffer) => Promise<void>;
};

export interface ZCLNodeCluster extends EventEmitter {
  /**
   * Command which requests the remote cluster to report its generated commands.
   */
  discoverCommandsGenerated(opts?: {
    startValue?: number;
    maxResults?: number;
  }): Promise<number[]>;

  /**
   * Command which requests the remote cluster to report its received commands.
   */
  discoverCommandsReceived(opts?: {
    startValue?: number;
    maxResults?: number;
  }): Promise<number[]>;

  /**
   * Command which reads a given set of attributes from the remote cluster.
   */
  readAttributes(
    attributeNames: string[],
    opts?: { timeout?: number }
  ): Promise<{ [x: string]: unknown }>;

  /**
   * Command which writes a given set of attribute key-value pairs to the remote cluster.
   */
  writeAttributes(attributes?: object): Promise<void>;

  /**
   * Command which configures attribute reporting for the given attributes on the remote cluster.
   */
  configureReporting(attributes?: object): Promise<void>;

  /**
   * Command which retrieves the reporting configurations for the given attributes.
   */
  readReportingConfiguration(attributes?: (string | number)[]): Promise<{
    status: string;
    direction: 'reported' | 'received';
    attributeId: number;
    attributeDataType?: number;
    minInterval?: number;
    maxInterval?: number;
    minChange?: number;
    timeoutPeriod?: number;
  }[]>;

  /**
   * Command which discovers the implemented attributes on the remote cluster.
   */
  discoverAttributes(): Promise<(string | number)[]>;

  /**
   * Command which discovers the implemented attributes with access control info.
   */
  discoverAttributesExtended(): Promise<{
    name?: string;
    id: number;
    acl: { readable: boolean; writable: boolean; reportable: boolean };
  }[]>;
}

export interface AlarmsCluster extends ZCLNodeCluster {
  resetAllAlarms(): Promise<void>;
  getAlarm(): Promise<void>;
  resetAlarmLog(): Promise<void>;
}

export interface AnalogInputClusterAttributes {
  description?: string;
  maxPresentValue?: unknown;
  minPresentValue?: unknown;
  outOfService?: boolean;
  presentValue?: unknown;
  reliability?: 'noFaultDetected' | 'noSensor' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'noOutput' | 'unreliableOther' | 'processError' | 'configurationError';
  resolution?: unknown;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface AnalogInputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'maxPresentValue' | 'minPresentValue' | 'outOfService' | 'presentValue' | 'reliability' | 'resolution' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<AnalogInputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<AnalogInputClusterAttributes>): Promise<void>;
}

export interface AnalogOutputClusterAttributes {
  description?: string;
  maxPresentValue?: unknown;
  minPresentValue?: unknown;
  outOfService?: boolean;
  presentValue?: unknown;
  reliability?: 'noFaultDetected' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'unreliableOther' | 'processError' | 'configurationError';
  relinquishDefault?: unknown;
  resolution?: unknown;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface AnalogOutputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'maxPresentValue' | 'minPresentValue' | 'outOfService' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'resolution' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<AnalogOutputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<AnalogOutputClusterAttributes>): Promise<void>;
}

export interface AnalogValueClusterAttributes {
  description?: string;
  outOfService?: boolean;
  presentValue?: unknown;
  reliability?: 'noFaultDetected' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'unreliableOther' | 'processError' | 'configurationError';
  relinquishDefault?: unknown;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface AnalogValueCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'outOfService' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<AnalogValueClusterAttributes, K>>;
  writeAttributes(attributes: Partial<AnalogValueClusterAttributes>): Promise<void>;
}

export interface BallastConfigurationClusterAttributes {
  physicalMinLevel?: number;
  physicalMaxLevel?: number;
  ballastStatus?: Partial<{ nonOperational: boolean; lampNotInSocket: boolean }>;
  minLevel?: number;
  maxLevel?: number;
  powerOnLevel?: number;
  powerOnFadeTime?: number;
  intrinsicBallastFactor?: number;
  ballastFactorAdjustment?: number;
  lampQuantity?: number;
  lampType?: string;
  lampManufacturer?: string;
  lampRatedHours?: number;
  lampBurnHours?: number;
  lampAlarmMode?: Partial<{ lampBurnHours: boolean }>;
  lampBurnHoursTripPoint?: number;
}

export interface BallastConfigurationCluster extends ZCLNodeCluster {
  readAttributes<K extends 'physicalMinLevel' | 'physicalMaxLevel' | 'ballastStatus' | 'minLevel' | 'maxLevel' | 'powerOnLevel' | 'powerOnFadeTime' | 'intrinsicBallastFactor' | 'ballastFactorAdjustment' | 'lampQuantity' | 'lampType' | 'lampManufacturer' | 'lampRatedHours' | 'lampBurnHours' | 'lampAlarmMode' | 'lampBurnHoursTripPoint'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<BallastConfigurationClusterAttributes, K>>;
  writeAttributes(attributes: Partial<BallastConfigurationClusterAttributes>): Promise<void>;
}

export interface BasicClusterAttributes {
  zclVersion?: number;
  appVersion?: number;
  stackVersion?: number;
  hwVersion?: number;
  manufacturerName?: string;
  modelId?: string;
  dateCode?: string;
  powerSource?: unknown;
  appProfileVersion?: number;
  locationDesc?: string;
  physicalEnv?: unknown;
  deviceEnabled?: boolean;
  alarmMask?: Partial<{ hardwareFault: boolean; softwareFault: boolean }>;
  disableLocalConfig?: Partial<{ factoryResetDisabled: boolean; configurationDisabled: boolean }>;
  swBuildId?: string;
}

export interface BasicCluster extends ZCLNodeCluster {
  readAttributes<K extends 'zclVersion' | 'appVersion' | 'stackVersion' | 'hwVersion' | 'manufacturerName' | 'modelId' | 'dateCode' | 'powerSource' | 'appProfileVersion' | 'locationDesc' | 'physicalEnv' | 'deviceEnabled' | 'alarmMask' | 'disableLocalConfig' | 'swBuildId'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<BasicClusterAttributes, K>>;
  writeAttributes(attributes: Partial<BasicClusterAttributes>): Promise<void>;
  factoryReset(): Promise<void>;
}

export interface BinaryInputClusterAttributes {
  activeText?: string;
  description?: string;
  inactiveText?: string;
  outOfService?: boolean;
  polarity?: 'normal' | 'reverse';
  presentValue?: boolean;
  reliability?: 'noFaultDetected' | 'noSensor' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'noOutput' | 'unreliableOther' | 'processError' | 'configurationError';
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface BinaryInputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'activeText' | 'description' | 'inactiveText' | 'outOfService' | 'polarity' | 'presentValue' | 'reliability' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<BinaryInputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<BinaryInputClusterAttributes>): Promise<void>;
}

export interface BinaryOutputClusterAttributes {
  activeText?: string;
  description?: string;
  inactiveText?: string;
  minimumOffTime?: number;
  minimumOnTime?: number;
  outOfService?: boolean;
  polarity?: 'normal' | 'reverse';
  presentValue?: boolean;
  reliability?: 'noFaultDetected' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'unreliableOther' | 'processError' | 'configurationError';
  relinquishDefault?: boolean;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface BinaryOutputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'activeText' | 'description' | 'inactiveText' | 'minimumOffTime' | 'minimumOnTime' | 'outOfService' | 'polarity' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<BinaryOutputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<BinaryOutputClusterAttributes>): Promise<void>;
}

export interface BinaryValueClusterAttributes {
  activeText?: string;
  description?: string;
  inactiveText?: string;
  minimumOffTime?: number;
  minimumOnTime?: number;
  outOfService?: boolean;
  polarity?: 'normal' | 'reverse';
  presentValue?: boolean;
  reliability?: 'noFaultDetected' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'unreliableOther' | 'processError' | 'configurationError';
  relinquishDefault?: boolean;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface BinaryValueCluster extends ZCLNodeCluster {
  readAttributes<K extends 'activeText' | 'description' | 'inactiveText' | 'minimumOffTime' | 'minimumOnTime' | 'outOfService' | 'polarity' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<BinaryValueClusterAttributes, K>>;
  writeAttributes(attributes: Partial<BinaryValueClusterAttributes>): Promise<void>;
}

export interface ColorControlClusterAttributes {
  currentHue?: number;
  currentSaturation?: number;
  currentX?: number;
  currentY?: number;
  colorTemperatureMireds?: number;
  colorMode?: 'currentHueAndCurrentSaturation' | 'currentXAndCurrentY' | 'colorTemperatureMireds';
  colorCapabilities?: Partial<{ hueAndSaturation: boolean; enhancedHue: boolean; colorLoop: boolean; xy: boolean; colorTemperature: boolean }>;
  colorTempPhysicalMinMireds?: number;
  colorTempPhysicalMaxMireds?: number;
}

export interface ColorControlCluster extends ZCLNodeCluster {
  readAttributes<K extends 'currentHue' | 'currentSaturation' | 'currentX' | 'currentY' | 'colorTemperatureMireds' | 'colorMode' | 'colorCapabilities' | 'colorTempPhysicalMinMireds' | 'colorTempPhysicalMaxMireds'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<ColorControlClusterAttributes, K>>;
  writeAttributes(attributes: Partial<ColorControlClusterAttributes>): Promise<void>;
  moveToHue(args: { hue: number; direction: 'shortestDistance' | 'longestDistance' | 'up' | 'down'; transitionTime: number }): Promise<void>;
  moveToSaturation(args: { saturation: number; transitionTime: number }): Promise<void>;
  moveToHueAndSaturation(args: { hue: number; saturation: number; transitionTime: number }): Promise<void>;
  moveToColor(args: { colorX: number; colorY: number; transitionTime: number }): Promise<void>;
  moveToColorTemperature(args: { colorTemperature: number; transitionTime: number }): Promise<void>;
}

export interface DehumidificationControlCluster extends ZCLNodeCluster {
}

export interface DeviceTemperatureClusterAttributes {
  currentTemperature?: number;
  minTempExperienced?: number;
  maxTempExperienced?: number;
  overTempTotalDwell?: number;
  deviceTempAlarmMask?: Partial<{ deviceTemperatureTooLow: boolean; deviceTemperatureTooHigh: boolean }>;
  lowTempThreshold?: number;
  highTempThreshold?: number;
  lowTempDwellTripPoint?: number;
  highTempDwellTripPoint?: number;
}

export interface DeviceTemperatureCluster extends ZCLNodeCluster {
  readAttributes<K extends 'currentTemperature' | 'minTempExperienced' | 'maxTempExperienced' | 'overTempTotalDwell' | 'deviceTempAlarmMask' | 'lowTempThreshold' | 'highTempThreshold' | 'lowTempDwellTripPoint' | 'highTempDwellTripPoint'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<DeviceTemperatureClusterAttributes, K>>;
  writeAttributes(attributes: Partial<DeviceTemperatureClusterAttributes>): Promise<void>;
}

export interface DiagnosticsCluster extends ZCLNodeCluster {
}

export interface DoorLockClusterAttributes {
  lockState?: 'notFullyLocked' | 'locked' | 'unlocked' | 'undefined';
  lockType?: 'deadBolt' | 'magnetic' | 'other' | 'mortise' | 'rim' | 'latchBolt' | 'cylindricalLock' | 'tubularLock' | 'interconnectedLock' | 'deadLatch' | 'doorFurniture';
  actuatorEnabled?: boolean;
  doorState?: 'open' | 'closed' | 'errorJammed' | 'errorForcedOpen' | 'errorUnspecified' | 'undefined';
  doorOpenEvents?: number;
  doorClosedEvents?: number;
  openPeriod?: number;
  numberOfLogRecordsSupported?: number;
  numberOfTotalUsersSupported?: number;
  numberOfPINUsersSupported?: number;
  numberOfRFIDUsersSupported?: number;
  numberOfWeekDaySchedulesSupportedPerUser?: number;
  numberOfYearDaySchedulesSupportedPerUser?: number;
  numberOfHolidaySchedulesSupported?: number;
  maxPINCodeLength?: number;
  minPINCodeLength?: number;
  maxRFIDCodeLength?: number;
  minRFIDCodeLength?: number;
  enableLogging?: boolean;
  language?: string;
  ledSettings?: number;
  autoRelockTime?: number;
  soundVolume?: number;
  operatingMode?: 'normal' | 'vacation' | 'privacy' | 'noRFLockOrUnlock' | 'passage';
  supportedOperatingModes?: Partial<{ normal: boolean; vacation: boolean; privacy: boolean; noRFLockOrUnlock: boolean; passage: boolean }>;
  defaultConfigurationRegister?: Partial<{ enableLocalProgramming: boolean; keypadInterfaceDefaultAccess: boolean; rfInterfaceDefaultAccess: boolean; reserved3: boolean; reserved4: boolean; soundEnabled: boolean; autoRelockTimeSet: boolean; ledSettingsSet: boolean }>;
  enableLocalProgramming?: boolean;
  enableOneTouchLocking?: boolean;
  enableInsideStatusLED?: boolean;
  enablePrivacyModeButton?: boolean;
  wrongCodeEntryLimit?: number;
  userCodeTemporaryDisableTime?: number;
  sendPINOverTheAir?: boolean;
  requirePINforRFOperation?: boolean;
  securityLevel?: 'network' | 'apsLinkKey';
  alarmMask?: Partial<{ deadboltJammed: boolean; lockResetToFactoryDefaults: boolean; reserved2: boolean; rfModulePowerCycled: boolean; tamperAlarmWrongCodeEntryLimit: boolean; tamperAlarmFrontEscutcheonRemoved: boolean; forcedDoorOpenUnderDoorLockedCondition: boolean }>;
  keypadOperationEventMask?: Partial<{ unknownOrManufacturerSpecificKeypadOperationEvent: boolean; lockSourceKeypad: boolean; unlockSourceKeypad: boolean; lockSourceKeypadErrorInvalidPIN: boolean; lockSourceKeypadErrorInvalidSchedule: boolean; unlockSourceKeypadErrorInvalidCode: boolean; unlockSourceKeypadErrorInvalidSchedule: boolean; nonAccessUserOperationEventSourceKeypad: boolean }>;
  rfOperationEventMask?: Partial<{ unknownOrManufacturerSpecificKeypadOperationEvent: boolean; lockSourceRF: boolean; unlockSourceRF: boolean; lockSourceRFErrorInvalidCode: boolean; lockSourceRFErrorInvalidSchedule: boolean; unlockSourceRFErrorInvalidCode: boolean; unlockSourceRFErrorInvalidSchedule: boolean }>;
  manualOperationEventMask?: Partial<{ unknownOrManufacturerSpecificManualOperationEvent: boolean; thumbturnLock: boolean; thumbturnUnlock: boolean; oneTouchLock: boolean; keyLock: boolean; keyUnlock: boolean; autoLock: boolean; scheduleLock: boolean; scheduleUnlock: boolean; manualLock: boolean; manualUnlock: boolean }>;
  rfidOperationEventMask?: Partial<{ unknownOrManufacturerSpecificKeypadOperationEvent: boolean; lockSourceRFID: boolean; unlockSourceRFID: boolean; lockSourceRFIDErrorInvalidRFIDID: boolean; lockSourceRFIDErrorInvalidSchedule: boolean; unlockSourceRFIDErrorInvalidRFIDID: boolean; unlockSourceRFIDErrorInvalidSchedule: boolean }>;
  keypadProgrammingEventMask?: Partial<{ unknownOrManufacturerSpecificKeypadProgrammingEvent: boolean; masterCodeChanged: boolean; pinCodeAdded: boolean; pinCodeDeleted: boolean; pinCodeChanged: boolean }>;
  rfProgrammingEventMask?: Partial<{ unknownOrManufacturerSpecificRFProgrammingEvent: boolean; reserved1: boolean; pinCodeAdded: boolean; pinCodeDeleted: boolean; pinCodeChanged: boolean; rfidCodeAdded: boolean; rfidCodeDeleted: boolean }>;
  rfidProgrammingEventMask?: Partial<{ unknownOrManufacturerSpecificRFIDProgrammingEvent: boolean; rfidCodeAdded: boolean; rfidCodeDeleted: boolean }>;
}

export interface DoorLockCluster extends ZCLNodeCluster {
  readAttributes<K extends 'lockState' | 'lockType' | 'actuatorEnabled' | 'doorState' | 'doorOpenEvents' | 'doorClosedEvents' | 'openPeriod' | 'numberOfLogRecordsSupported' | 'numberOfTotalUsersSupported' | 'numberOfPINUsersSupported' | 'numberOfRFIDUsersSupported' | 'numberOfWeekDaySchedulesSupportedPerUser' | 'numberOfYearDaySchedulesSupportedPerUser' | 'numberOfHolidaySchedulesSupported' | 'maxPINCodeLength' | 'minPINCodeLength' | 'maxRFIDCodeLength' | 'minRFIDCodeLength' | 'enableLogging' | 'language' | 'ledSettings' | 'autoRelockTime' | 'soundVolume' | 'operatingMode' | 'supportedOperatingModes' | 'defaultConfigurationRegister' | 'enableLocalProgramming' | 'enableOneTouchLocking' | 'enableInsideStatusLED' | 'enablePrivacyModeButton' | 'wrongCodeEntryLimit' | 'userCodeTemporaryDisableTime' | 'sendPINOverTheAir' | 'requirePINforRFOperation' | 'securityLevel' | 'alarmMask' | 'keypadOperationEventMask' | 'rfOperationEventMask' | 'manualOperationEventMask' | 'rfidOperationEventMask' | 'keypadProgrammingEventMask' | 'rfProgrammingEventMask' | 'rfidProgrammingEventMask'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<DoorLockClusterAttributes, K>>;
  writeAttributes(attributes: Partial<DoorLockClusterAttributes>): Promise<void>;
  lockDoor(args: { pinCode?: Buffer }): Promise<void>;
  unlockDoor(args: { pinCode?: Buffer }): Promise<void>;
  toggle(args: { pinCode?: Buffer }): Promise<void>;
  unlockWithTimeout(args: { timeout: number; pinCode?: Buffer }): Promise<void>;
  getLogRecord(args: { logIndex: number }): Promise<void>;
  setPINCode(args: { userId: number; userStatus: 'available' | 'occupiedEnabled' | 'occupiedDisabled' | 'notSupported'; userType: 'unrestricted' | 'yearDayScheduleUser' | 'weekDayScheduleUser' | 'masterUser' | 'nonAccessUser' | 'notSupported'; pinCode?: Buffer }): Promise<void>;
  getPINCode(args: { userId: number }): Promise<void>;
  clearPINCode(args: { userId: number }): Promise<void>;
  clearAllPINCodes(): Promise<void>;
  setUserStatus(args: { userId: number; userStatus: 'available' | 'occupiedEnabled' | 'occupiedDisabled' | 'notSupported' }): Promise<void>;
  getUserStatus(args: { userId: number }): Promise<void>;
  setWeekDaySchedule(args: { scheduleId: number; userId: number; daysMask: Partial<{ sunday: boolean; monday: boolean; tuesday: boolean; wednesday: boolean; thursday: boolean; friday: boolean; saturday: boolean }>; startHour: number; startMinute: number; endHour: number; endMinute: number }): Promise<void>;
  getWeekDaySchedule(args: { scheduleId: number; userId: number }): Promise<void>;
  clearWeekDaySchedule(args: { scheduleId: number; userId: number }): Promise<void>;
  setYearDaySchedule(args: { scheduleId: number; userId: number; localStartTime: number; localEndTime: number }): Promise<void>;
  getYearDaySchedule(args: { scheduleId: number; userId: number }): Promise<void>;
  clearYearDaySchedule(args: { scheduleId: number; userId: number }): Promise<void>;
  setHolidaySchedule(args: { holidayScheduleId: number; localStartTime: number; localEndTime: number; operatingModeDuringHoliday: 'normal' | 'vacation' | 'privacy' | 'noRFLockOrUnlock' | 'passage' }): Promise<void>;
  getHolidaySchedule(args: { holidayScheduleId: number }): Promise<void>;
  clearHolidaySchedule(args: { holidayScheduleId: number }): Promise<void>;
  setUserType(args: { userId: number; userType: 'unrestricted' | 'yearDayScheduleUser' | 'weekDayScheduleUser' | 'masterUser' | 'nonAccessUser' | 'notSupported' }): Promise<void>;
  getUserType(args: { userId: number }): Promise<void>;
  setRFIDCode(args: { userId: number; userStatus: 'available' | 'occupiedEnabled' | 'occupiedDisabled' | 'notSupported'; userType: 'unrestricted' | 'yearDayScheduleUser' | 'weekDayScheduleUser' | 'masterUser' | 'nonAccessUser' | 'notSupported'; rfidCode?: Buffer }): Promise<void>;
  getRFIDCode(args: { userId: number }): Promise<void>;
  clearRFIDCode(args: { userId: number }): Promise<void>;
  clearAllRFIDCodes(): Promise<void>;
}

export interface ElectricalMeasurementClusterAttributes {
  measurementType?: Partial<{ activeMeasurementAC: boolean; reactiveMeasurementAC: boolean; apparentMeasurementAC: boolean; phaseAMeasurement: boolean; phaseBMeasurement: boolean; phaseCMeasurement: boolean; dcMeasurement: boolean; harmonicsMeasurement: boolean; powerQualityMeasurement: boolean }>;
  acFrequency?: number;
  measuredPhase1stHarmonicCurrent?: number;
  acFrequencyMultiplier?: number;
  acFrequencyDivisor?: number;
  phaseHarmonicCurrentMultiplier?: number;
  rmsVoltage?: number;
  rmsCurrent?: number;
  activePower?: number;
  reactivePower?: number;
  acVoltageMultiplier?: number;
  acVoltageDivisor?: number;
  acCurrentMultiplier?: number;
  acCurrentDivisor?: number;
  acPowerMultiplier?: number;
  acPowerDivisor?: number;
  acAlarmsMask?: Partial<{ voltageOverload: boolean; currentOverload: boolean; activePowerOverload: boolean; reactivePowerOverload: boolean; averageRMSOverVoltage: boolean; averageRMSUnderVoltage: boolean; rmsExtremeOverVoltage: boolean; rmsExtremeUnderVoltage: boolean; rmsVoltageSag: boolean; rmsVoltageSwell: boolean }>;
  acVoltageOverload?: number;
  acCurrentOverload?: number;
  acActivePowerOverload?: number;
}

export interface ElectricalMeasurementCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measurementType' | 'acFrequency' | 'measuredPhase1stHarmonicCurrent' | 'acFrequencyMultiplier' | 'acFrequencyDivisor' | 'phaseHarmonicCurrentMultiplier' | 'rmsVoltage' | 'rmsCurrent' | 'activePower' | 'reactivePower' | 'acVoltageMultiplier' | 'acVoltageDivisor' | 'acCurrentMultiplier' | 'acCurrentDivisor' | 'acPowerMultiplier' | 'acPowerDivisor' | 'acAlarmsMask' | 'acVoltageOverload' | 'acCurrentOverload' | 'acActivePowerOverload'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<ElectricalMeasurementClusterAttributes, K>>;
  writeAttributes(attributes: Partial<ElectricalMeasurementClusterAttributes>): Promise<void>;
}

export interface FanControlCluster extends ZCLNodeCluster {
}

export interface FlowMeasurementClusterAttributes {
  measuredValue?: number;
  minMeasuredValue?: number;
  maxMeasuredValue?: number;
  tolerance?: number;
}

export interface FlowMeasurementCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measuredValue' | 'minMeasuredValue' | 'maxMeasuredValue' | 'tolerance'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<FlowMeasurementClusterAttributes, K>>;
  writeAttributes(attributes: Partial<FlowMeasurementClusterAttributes>): Promise<void>;
}

export interface GroupsClusterAttributes {
  nameSupport?: Partial<{ groupNames: boolean }>;
}

export interface GroupsCluster extends ZCLNodeCluster {
  readAttributes<K extends 'nameSupport'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<GroupsClusterAttributes, K>>;
  writeAttributes(attributes: Partial<GroupsClusterAttributes>): Promise<void>;
  addGroup(args: { groupId: number; groupName: string }): Promise<void>;
  viewGroup(args: { groupId: number }): Promise<void>;
  getGroupMembership(args: { groupIds: number }): Promise<void>;
  removeGroup(args: { groupId: number }): Promise<void>;
  removeAllGroups(): Promise<void>;
  addGroupIfIdentify(args: { groupId: number; groupName: string }): Promise<void>;
}

export interface IasACECluster extends ZCLNodeCluster {
}

export interface IasWDCluster extends ZCLNodeCluster {
}

export interface IasZoneClusterAttributes {
  zoneState?: 'notEnrolled' | 'enrolled';
  zoneType?: 'standardCIE' | 'motionSensor' | 'contactSwitch' | 'fireSensor' | 'waterSensor' | 'cabonMonoxideSensor' | 'personalEmergencyDevice' | 'vibrationMovementSensor' | 'remoteControl' | 'keyfob' | 'keypad' | 'standardWarningDevice' | 'glassBreakSensor' | 'securityRepeater' | 'invalidZoneType';
  zoneStatus?: unknown;
  iasCIEAddress?: string;
  zoneId?: number;
}

export interface IasZoneCluster extends ZCLNodeCluster {
  readAttributes<K extends 'zoneState' | 'zoneType' | 'zoneStatus' | 'iasCIEAddress' | 'zoneId'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<IasZoneClusterAttributes, K>>;
  writeAttributes(attributes: Partial<IasZoneClusterAttributes>): Promise<void>;
  zoneStatusChangeNotification(args: { zoneStatus: unknown; extendedStatus: number; zoneId: number; delay: number }): Promise<void>;
  zoneEnrollResponse(args: { enrollResponseCode: 'success' | 'notSupported' | 'noEnrollPermit' | 'tooManyZones'; zoneId: number }): Promise<void>;
  zoneEnrollRequest(args: { zoneType: 'standard' | 'motionSensor' | 'contactSwitch' | 'fireSensor' | 'waterSensor' | 'carbonMonoxideSensor' | 'personalEmergencyDevice' | 'vibrationMovementSensor' | 'remoteControl' | 'keyFob' | 'keyPad' | 'standardWarningDevice' | 'glassBreakSensor' | 'securityRepeater' | 'invalid'; manufacturerCode: number }): Promise<void>;
  initiateNormalOperationMode(): Promise<void>;
}

export interface IdentifyClusterAttributes {
  identifyTime?: number;
}

export interface IdentifyCluster extends ZCLNodeCluster {
  readAttributes<K extends 'identifyTime'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<IdentifyClusterAttributes, K>>;
  writeAttributes(attributes: Partial<IdentifyClusterAttributes>): Promise<void>;
  identify(args: { identifyTime: number }): Promise<void>;
  identifyQuery(args: { timeout: number }): Promise<void>;
  triggerEffect(args: { effectIdentifier: 'blink' | 'breathe' | 'okay' | 'channelChange' | 'finish' | 'stop'; effectVariant: number }): Promise<void>;
}

export interface IlluminanceLevelSensingClusterAttributes {
  levelStatus?: 'illuminanceOnTarget' | 'illuminanceBelowTarget' | 'illuminanceAboveTarget';
  lightSensorType?: 'photodiode' | 'cmos' | 'unknown';
  illuminanceTargetLevel?: number;
}

export interface IlluminanceLevelSensingCluster extends ZCLNodeCluster {
  readAttributes<K extends 'levelStatus' | 'lightSensorType' | 'illuminanceTargetLevel'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<IlluminanceLevelSensingClusterAttributes, K>>;
  writeAttributes(attributes: Partial<IlluminanceLevelSensingClusterAttributes>): Promise<void>;
}

export interface IlluminanceMeasurementClusterAttributes {
  measuredValue?: number;
  minMeasuredValue?: number;
  maxMeasuredValue?: number;
  tolerance?: number;
  lightSensorType?: 'photodiode' | 'cmos' | 'unknown';
}

export interface IlluminanceMeasurementCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measuredValue' | 'minMeasuredValue' | 'maxMeasuredValue' | 'tolerance' | 'lightSensorType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<IlluminanceMeasurementClusterAttributes, K>>;
  writeAttributes(attributes: Partial<IlluminanceMeasurementClusterAttributes>): Promise<void>;
}

export interface LevelControlClusterAttributes {
  currentLevel?: number;
  remainingTime?: number;
  onOffTransitionTime?: number;
  onLevel?: number;
  onTransitionTime?: number;
  offTransitionTime?: number;
  defaultMoveRate?: number;
}

export interface LevelControlCluster extends ZCLNodeCluster {
  readAttributes<K extends 'currentLevel' | 'remainingTime' | 'onOffTransitionTime' | 'onLevel' | 'onTransitionTime' | 'offTransitionTime' | 'defaultMoveRate'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<LevelControlClusterAttributes, K>>;
  writeAttributes(attributes: Partial<LevelControlClusterAttributes>): Promise<void>;
  moveToLevel(args: { level: number; transitionTime: number }): Promise<void>;
  move(args: { moveMode: 'up' | 'down'; rate: number }): Promise<void>;
  step(args: { mode: 'up' | 'down'; stepSize: number; transitionTime: number }): Promise<void>;
  stop(): Promise<void>;
  moveToLevelWithOnOff(args: { level: number; transitionTime: number }): Promise<void>;
  moveWithOnOff(args: { moveMode: 'up' | 'down'; rate: number }): Promise<void>;
  stepWithOnOff(args: { mode: 'up' | 'down'; stepSize: number; transitionTime: number }): Promise<void>;
  stopWithOnOff(): Promise<void>;
}

export interface MeteringClusterAttributes {
  currentSummationDelivered?: number;
  currentSummationReceived?: number;
  currentMaxDemandDelivered?: number;
  currentMaxDemandReceived?: number;
  dftSummation?: number;
  dailyFreezeTime?: number;
  powerFactor?: number;
  readingSnapShotTime?: number;
  currentMaxDemandDeliveredTime?: number;
  currentMaxDemandReceivedTime?: number;
  defaultUpdatePeriod?: number;
  fastPollUpdatePeriod?: number;
  currentBlockPeriodConsumptionDelivered?: number;
  dailyConsumptionTarget?: number;
  currentBlock?: unknown;
  profileIntervalPeriod?: unknown;
  currentTier1SummationDelivered?: number;
  currentTier1SummationReceived?: number;
  currentTier2SummationDelivered?: number;
  currentTier2SummationReceived?: number;
  currentTier3SummationDelivered?: number;
  currentTier3SummationReceived?: number;
  currentTier4SummationDelivered?: number;
  currentTier4SummationReceived?: number;
  status?: unknown;
  remainingBatteryLife?: number;
  hoursInOperation?: number;
  hoursInFault?: number;
  extendedStatus?: unknown;
  unitOfMeasure?: unknown;
  multiplier?: number;
  divisor?: number;
  summationFormatting?: unknown;
  demandFormatting?: unknown;
  historicalConsumptionFormatting?: unknown;
  meteringDeviceType?: unknown;
  siteId?: Buffer;
  meterSerialNumber?: Buffer;
  energyCarrierUnitOfMeasure?: unknown;
  energyCarrierSummationFormatting?: unknown;
  energyCarrierDemandFormatting?: unknown;
  temperatureUnitOfMeasure?: unknown;
  temperatureFormatting?: unknown;
  moduleSerialNumber?: Buffer;
  operatingTariffLabelDelivered?: Buffer;
  operatingTariffLabelReceived?: Buffer;
  customerIdNumber?: Buffer;
  alternativeUnitOfMeasure?: unknown;
  alternativeDemandFormatting?: unknown;
  alternativeConsumptionFormatting?: unknown;
  instantaneousDemand?: number;
  currentDayConsumptionDelivered?: number;
  currentDayConsumptionReceived?: number;
  previousDayConsumptionDelivered?: number;
  previousDayConsumptionReceived?: number;
  currentPartialProfileIntervalStartTimeDelivered?: number;
  currentPartialProfileIntervalStartTimeReceived?: number;
  currentPartialProfileIntervalValueDelivered?: number;
  currentPartialProfileIntervalValueReceived?: number;
  currentDayMaxPressure?: number;
  currentDayMinPressure?: number;
  previousDayMaxPressure?: number;
  previousDayMinPressure?: number;
  currentDayMaxDemand?: number;
  previousDayMaxDemand?: number;
  currentMonthMaxDemand?: number;
  currentYearMaxDemand?: number;
  currentDayMaxEnergyCarrierDemand?: number;
  previousDayMaxEnergyCarrierDemand?: number;
  currentMonthMaxEnergyCarrierDemand?: number;
  currentMonthMinEnergyCarrierDemand?: number;
  currentYearMaxEnergyCarrierDemand?: number;
  currentYearMinEnergyCarrierDemand?: number;
  maxNumberOfPeriodsDelivered?: number;
  currentDemandDelivered?: number;
  demandLimit?: number;
  demandIntegrationPeriod?: number;
  numberOfDemandSubintervals?: number;
  demandLimitArmDuration?: number;
}

export interface MeteringCluster extends ZCLNodeCluster {
  readAttributes<K extends 'currentSummationDelivered' | 'currentSummationReceived' | 'currentMaxDemandDelivered' | 'currentMaxDemandReceived' | 'dftSummation' | 'dailyFreezeTime' | 'powerFactor' | 'readingSnapShotTime' | 'currentMaxDemandDeliveredTime' | 'currentMaxDemandReceivedTime' | 'defaultUpdatePeriod' | 'fastPollUpdatePeriod' | 'currentBlockPeriodConsumptionDelivered' | 'dailyConsumptionTarget' | 'currentBlock' | 'profileIntervalPeriod' | 'currentTier1SummationDelivered' | 'currentTier1SummationReceived' | 'currentTier2SummationDelivered' | 'currentTier2SummationReceived' | 'currentTier3SummationDelivered' | 'currentTier3SummationReceived' | 'currentTier4SummationDelivered' | 'currentTier4SummationReceived' | 'status' | 'remainingBatteryLife' | 'hoursInOperation' | 'hoursInFault' | 'extendedStatus' | 'unitOfMeasure' | 'multiplier' | 'divisor' | 'summationFormatting' | 'demandFormatting' | 'historicalConsumptionFormatting' | 'meteringDeviceType' | 'siteId' | 'meterSerialNumber' | 'energyCarrierUnitOfMeasure' | 'energyCarrierSummationFormatting' | 'energyCarrierDemandFormatting' | 'temperatureUnitOfMeasure' | 'temperatureFormatting' | 'moduleSerialNumber' | 'operatingTariffLabelDelivered' | 'operatingTariffLabelReceived' | 'customerIdNumber' | 'alternativeUnitOfMeasure' | 'alternativeDemandFormatting' | 'alternativeConsumptionFormatting' | 'instantaneousDemand' | 'currentDayConsumptionDelivered' | 'currentDayConsumptionReceived' | 'previousDayConsumptionDelivered' | 'previousDayConsumptionReceived' | 'currentPartialProfileIntervalStartTimeDelivered' | 'currentPartialProfileIntervalStartTimeReceived' | 'currentPartialProfileIntervalValueDelivered' | 'currentPartialProfileIntervalValueReceived' | 'currentDayMaxPressure' | 'currentDayMinPressure' | 'previousDayMaxPressure' | 'previousDayMinPressure' | 'currentDayMaxDemand' | 'previousDayMaxDemand' | 'currentMonthMaxDemand' | 'currentYearMaxDemand' | 'currentDayMaxEnergyCarrierDemand' | 'previousDayMaxEnergyCarrierDemand' | 'currentMonthMaxEnergyCarrierDemand' | 'currentMonthMinEnergyCarrierDemand' | 'currentYearMaxEnergyCarrierDemand' | 'currentYearMinEnergyCarrierDemand' | 'maxNumberOfPeriodsDelivered' | 'currentDemandDelivered' | 'demandLimit' | 'demandIntegrationPeriod' | 'numberOfDemandSubintervals' | 'demandLimitArmDuration'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<MeteringClusterAttributes, K>>;
  writeAttributes(attributes: Partial<MeteringClusterAttributes>): Promise<void>;
}

export interface MultistateInputClusterAttributes {
  description?: string;
  numberOfStates?: number;
  outOfService?: boolean;
  presentValue?: number;
  reliability?: 'noFaultDetected' | 'noSensor' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'noOutput' | 'unreliableOther' | 'processError' | 'multiStateFault' | 'configurationError';
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface MultistateInputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'numberOfStates' | 'outOfService' | 'presentValue' | 'reliability' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<MultistateInputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<MultistateInputClusterAttributes>): Promise<void>;
}

export interface MultistateOutputClusterAttributes {
  description?: string;
  numberOfStates?: number;
  outOfService?: boolean;
  presentValue?: number;
  reliability?: 'noFaultDetected' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'unreliableOther' | 'processError' | 'multiStateFault' | 'configurationError';
  relinquishDefault?: number;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface MultistateOutputCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'numberOfStates' | 'outOfService' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<MultistateOutputClusterAttributes, K>>;
  writeAttributes(attributes: Partial<MultistateOutputClusterAttributes>): Promise<void>;
}

export interface MultistateValueClusterAttributes {
  description?: string;
  numberOfStates?: number;
  outOfService?: boolean;
  presentValue?: number;
  reliability?: 'noFaultDetected' | 'noSensor' | 'overRange' | 'underRange' | 'openLoop' | 'shortedLoop' | 'noOutput' | 'unreliableOther' | 'processError' | 'multiStateFault' | 'configurationError';
  relinquishDefault?: number;
  statusFlags?: Partial<{ inAlarm: boolean; fault: boolean; overridden: boolean; outOfService: boolean }>;
  applicationType?: number;
}

export interface MultistateValueCluster extends ZCLNodeCluster {
  readAttributes<K extends 'description' | 'numberOfStates' | 'outOfService' | 'presentValue' | 'reliability' | 'relinquishDefault' | 'statusFlags' | 'applicationType'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<MultistateValueClusterAttributes, K>>;
  writeAttributes(attributes: Partial<MultistateValueClusterAttributes>): Promise<void>;
}

export interface OccupancySensingClusterAttributes {
  occupancy?: Partial<{ occupied: boolean }>;
  occupancySensorType?: 'pir' | 'ultrasonic' | 'pirAndUltrasonic' | 'physicalContact';
  occupancySensorTypeBitmap?: Partial<{ pir: boolean; ultrasonic: boolean; physicalContact: boolean }>;
  pirOccupiedToUnoccupiedDelay?: number;
  pirUnoccupiedToOccupiedDelay?: number;
  pirUnoccupiedToOccupiedThreshold?: number;
  ultrasonicOccupiedToUnoccupiedDelay?: number;
  ultrasonicUnoccupiedToOccupiedDelay?: number;
  ultrasonicUnoccupiedToOccupiedThreshold?: number;
  physicalContactOccupiedToUnoccupiedDelay?: number;
  physicalContactUnoccupiedToOccupiedDelay?: number;
  physicalContactUnoccupiedToOccupiedThreshold?: number;
}

export interface OccupancySensingCluster extends ZCLNodeCluster {
  readAttributes<K extends 'occupancy' | 'occupancySensorType' | 'occupancySensorTypeBitmap' | 'pirOccupiedToUnoccupiedDelay' | 'pirUnoccupiedToOccupiedDelay' | 'pirUnoccupiedToOccupiedThreshold' | 'ultrasonicOccupiedToUnoccupiedDelay' | 'ultrasonicUnoccupiedToOccupiedDelay' | 'ultrasonicUnoccupiedToOccupiedThreshold' | 'physicalContactOccupiedToUnoccupiedDelay' | 'physicalContactUnoccupiedToOccupiedDelay' | 'physicalContactUnoccupiedToOccupiedThreshold'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<OccupancySensingClusterAttributes, K>>;
  writeAttributes(attributes: Partial<OccupancySensingClusterAttributes>): Promise<void>;
}

export interface OnOffClusterAttributes {
  onOff?: boolean;
  onTime?: number;
  offWaitTime?: number;
}

export interface OnOffCluster extends ZCLNodeCluster {
  readAttributes<K extends 'onOff' | 'onTime' | 'offWaitTime'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<OnOffClusterAttributes, K>>;
  writeAttributes(attributes: Partial<OnOffClusterAttributes>): Promise<void>;
  setOff(): Promise<void>;
  setOn(): Promise<void>;
  toggle(): Promise<void>;
  offWithEffect(args: { effectIdentifier: number; effectVariant: number }): Promise<void>;
  onWithRecallGlobalScene(): Promise<void>;
  onWithTimedOff(args: { onOffControl: number; onTime: number; offWaitTime: number }): Promise<void>;
}

export interface OnOffSwitchCluster extends ZCLNodeCluster {
}

export interface OtaCluster extends ZCLNodeCluster {
}

export interface PollControlClusterAttributes {
  checkInInterval?: number;
  longPollInterval?: number;
  shortPollInterval?: number;
  fastPollTimeout?: number;
  checkInIntervalMin?: number;
  longPollIntervalMin?: number;
  fastPollTimeoutMax?: number;
}

export interface PollControlCluster extends ZCLNodeCluster {
  readAttributes<K extends 'checkInInterval' | 'longPollInterval' | 'shortPollInterval' | 'fastPollTimeout' | 'checkInIntervalMin' | 'longPollIntervalMin' | 'fastPollTimeoutMax'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<PollControlClusterAttributes, K>>;
  writeAttributes(attributes: Partial<PollControlClusterAttributes>): Promise<void>;
  fastPollStop(): Promise<void>;
  setLongPollInterval(args: { newLongPollInterval: number }): Promise<void>;
  setShortPollInterval(args: { newShortPollInterval: number }): Promise<void>;
}

export interface PowerConfigurationClusterAttributes {
  batteryVoltage?: number;
  batteryPercentageRemaining?: number;
  batterySize?: 'noBattery' | 'builtIn' | 'other' | 'AA' | 'AAA' | 'C' | 'D' | 'CR2' | 'CR123A' | 'unknown';
  batteryQuantity?: number;
  batteryRatedVoltage?: number;
  batteryVoltageMinThreshold?: number;
  batteryAlarmState?: Partial<{ batteryThresholdBatterySource1: boolean; batteryThreshold1BatterySource1: boolean; batteryThreshold2BatterySource1: boolean; batteryThreshold3BatterySource1: boolean; reserved4: boolean; reserved5: boolean; reserved6: boolean; reserved7: boolean; reserved8: boolean; reserved9: boolean; batteryThresholdBatterySource2: boolean; batteryThreshold1BatterySource2: boolean; batteryThreshold2BatterySource2: boolean; batteryThreshold3BatterySource2: boolean; reserved14: boolean; reserved15: boolean; reserved16: boolean; reserved17: boolean; reserved18: boolean; reserved19: boolean; batteryThresholdBatterySource3: boolean; batteryThreshold1BatterySource3: boolean; batteryThreshold2BatterySource3: boolean; batteryThreshold3BatterySource3: boolean; reserved24: boolean; reserved25: boolean; reserved26: boolean; reserved27: boolean; reserved28: boolean; reserved29: boolean; mainsPowerSupplyLostUnavailable: boolean }>;
}

export interface PowerConfigurationCluster extends ZCLNodeCluster {
  readAttributes<K extends 'batteryVoltage' | 'batteryPercentageRemaining' | 'batterySize' | 'batteryQuantity' | 'batteryRatedVoltage' | 'batteryVoltageMinThreshold' | 'batteryAlarmState'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<PowerConfigurationClusterAttributes, K>>;
  writeAttributes(attributes: Partial<PowerConfigurationClusterAttributes>): Promise<void>;
}

export interface PowerProfileCluster extends ZCLNodeCluster {
}

export interface PressureMeasurementClusterAttributes {
  measuredValue?: number;
  minMeasuredValue?: number;
  maxMeasuredValue?: number;
  tolerance?: number;
  scaledValue?: number;
  minScaledValue?: number;
  maxScaledValue?: number;
  scaledTolerance?: number;
  scale?: number;
}

export interface PressureMeasurementCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measuredValue' | 'minMeasuredValue' | 'maxMeasuredValue' | 'tolerance' | 'scaledValue' | 'minScaledValue' | 'maxScaledValue' | 'scaledTolerance' | 'scale'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<PressureMeasurementClusterAttributes, K>>;
  writeAttributes(attributes: Partial<PressureMeasurementClusterAttributes>): Promise<void>;
}

export interface PumpConfigurationAndControlCluster extends ZCLNodeCluster {
}

export interface RelativeHumidityClusterAttributes {
  measuredValue?: number;
  minMeasuredValue?: number;
  maxMeasuredValue?: number;
  tolerance?: number;
}

export interface RelativeHumidityCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measuredValue' | 'minMeasuredValue' | 'maxMeasuredValue' | 'tolerance'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<RelativeHumidityClusterAttributes, K>>;
  writeAttributes(attributes: Partial<RelativeHumidityClusterAttributes>): Promise<void>;
}

export interface ScenesCluster extends ZCLNodeCluster {
}

export interface ShadeConfigurationCluster extends ZCLNodeCluster {
}

export interface TemperatureMeasurementClusterAttributes {
  measuredValue?: number;
  minMeasuredValue?: number;
  maxMeasuredValue?: number;
}

export interface TemperatureMeasurementCluster extends ZCLNodeCluster {
  readAttributes<K extends 'measuredValue' | 'minMeasuredValue' | 'maxMeasuredValue'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<TemperatureMeasurementClusterAttributes, K>>;
  writeAttributes(attributes: Partial<TemperatureMeasurementClusterAttributes>): Promise<void>;
}

export interface ThermostatClusterAttributes {
  localTemperature?: number;
  outdoorTemperature?: number;
  occupancy?: Partial<{ occupied: boolean }>;
  absMinHeatSetpointLimit?: number;
  absMaxHeatSetpointLimit?: number;
  absMinCoolSetpointLimit?: number;
  absMaxCoolSetpointLimit?: number;
  pICoolingDemand?: number;
  pIHeatingDemand?: number;
  localTemperatureCalibration?: number;
  occupiedCoolingSetpoint?: number;
  occupiedHeatingSetpoint?: number;
  unoccupiedCoolingSetpoint?: number;
  unoccupiedHeatingSetpoint?: number;
  minHeatSetpointLimit?: number;
  maxHeatSetpointLimit?: number;
  minCoolSetpointLimit?: number;
  maxCoolSetpointLimit?: number;
  minSetpointDeadBand?: number;
  remoteSensing?: Partial<{ localTemperature: boolean; outdoorTemperature: boolean; occupancy: boolean }>;
  controlSequenceOfOperation?: 'cooling' | 'coolingWithReheat' | 'heating' | 'heatingWithReheat' | 'coolingAndHeating4Pipes' | 'coolingAndHeating4PipesWithReheat';
  systemMode?: 'off' | 'auto' | 'cool' | 'heat' | 'emergencyHeating' | 'precooling' | 'fanOnly' | 'dry' | 'sleep';
  alarmMask?: Partial<{ initializationFailure: boolean; hardwareFailure: boolean; selfCalibrationFailure: boolean }>;
}

export interface ThermostatCluster extends ZCLNodeCluster {
  readAttributes<K extends 'localTemperature' | 'outdoorTemperature' | 'occupancy' | 'absMinHeatSetpointLimit' | 'absMaxHeatSetpointLimit' | 'absMinCoolSetpointLimit' | 'absMaxCoolSetpointLimit' | 'pICoolingDemand' | 'pIHeatingDemand' | 'localTemperatureCalibration' | 'occupiedCoolingSetpoint' | 'occupiedHeatingSetpoint' | 'unoccupiedCoolingSetpoint' | 'unoccupiedHeatingSetpoint' | 'minHeatSetpointLimit' | 'maxHeatSetpointLimit' | 'minCoolSetpointLimit' | 'maxCoolSetpointLimit' | 'minSetpointDeadBand' | 'remoteSensing' | 'controlSequenceOfOperation' | 'systemMode' | 'alarmMask'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<ThermostatClusterAttributes, K>>;
  writeAttributes(attributes: Partial<ThermostatClusterAttributes>): Promise<void>;
  setSetpoint(args: { mode: 'heat' | 'cool' | 'both'; amount: number }): Promise<void>;
}

export interface TimeCluster extends ZCLNodeCluster {
}

export interface TouchlinkCluster extends ZCLNodeCluster {
  getGroups(args: { startIdx: number }): Promise<void>;
}

export interface WindowCoveringClusterAttributes {
  windowCoveringType?: 'rollershade' | 'rollershade2Motor' | 'rollershadeExterior' | 'rollershadeExterior2Motor' | 'drapery' | 'awning' | 'shutter' | 'tiltBlindTiltOnly' | 'tiltBlindLiftAndTilt' | 'projectorScreen';
  physicalClosedLimitLift?: number;
  physicalClosedLimitTilt?: number;
  currentPositionLift?: number;
  currentPositionTilt?: number;
  numberofActuationsLift?: number;
  numberofActuationsTilt?: number;
  configStatus?: Partial<{ operational: boolean; online: boolean; reversalLiftCommands: boolean; controlLift: boolean; controlTilt: boolean; encoderLift: boolean; encoderTilt: boolean; reserved: boolean }>;
  currentPositionLiftPercentage?: number;
  currentPositionTiltPercentage?: number;
  installedOpenLimitLift?: number;
  installedClosedLimitLift?: number;
  installedOpenLimitTilt?: number;
  installedClosedLimitTilt?: number;
  velocityLift?: number;
  accelerationTimeLift?: number;
  decelerationTimeLift?: number;
  mode?: Partial<{ motorDirectionReversed: boolean; calibrationMode: boolean; maintenanceMode: boolean; ledFeedback: boolean }>;
  intermediateSetpointsLift?: Buffer;
  intermediateSetpointsTilt?: Buffer;
}

export interface WindowCoveringCluster extends ZCLNodeCluster {
  readAttributes<K extends 'windowCoveringType' | 'physicalClosedLimitLift' | 'physicalClosedLimitTilt' | 'currentPositionLift' | 'currentPositionTilt' | 'numberofActuationsLift' | 'numberofActuationsTilt' | 'configStatus' | 'currentPositionLiftPercentage' | 'currentPositionTiltPercentage' | 'installedOpenLimitLift' | 'installedClosedLimitLift' | 'installedOpenLimitTilt' | 'installedClosedLimitTilt' | 'velocityLift' | 'accelerationTimeLift' | 'decelerationTimeLift' | 'mode' | 'intermediateSetpointsLift' | 'intermediateSetpointsTilt'>(attributeNames: K[], opts?: { timeout?: number }): Promise<Pick<WindowCoveringClusterAttributes, K>>;
  writeAttributes(attributes: Partial<WindowCoveringClusterAttributes>): Promise<void>;
  upOpen(): Promise<void>;
  downClose(): Promise<void>;
  stop(): Promise<void>;
  goToLiftValue(args: { liftValue: number }): Promise<void>;
  goToLiftPercentage(args: { percentageLiftValue: number }): Promise<void>;
  goToTiltValue(args: { tiltValue: number }): Promise<void>;
  goToTiltPercentage(args: { percentageTiltValue: number }): Promise<void>;
}

/** Type-safe cluster registry */
export interface ClusterRegistry {
  alarms?: AlarmsCluster;
  analogInput?: AnalogInputCluster;
  analogOutput?: AnalogOutputCluster;
  analogValue?: AnalogValueCluster;
  ballastConfiguration?: BallastConfigurationCluster;
  basic?: BasicCluster;
  binaryInput?: BinaryInputCluster;
  binaryOutput?: BinaryOutputCluster;
  binaryValue?: BinaryValueCluster;
  colorControl?: ColorControlCluster;
  dehumidificationControl?: DehumidificationControlCluster;
  deviceTemperature?: DeviceTemperatureCluster;
  diagnostics?: DiagnosticsCluster;
  doorLock?: DoorLockCluster;
  electricalMeasurement?: ElectricalMeasurementCluster;
  fanControl?: FanControlCluster;
  flowMeasurement?: FlowMeasurementCluster;
  groups?: GroupsCluster;
  iasACE?: IasACECluster;
  iasWD?: IasWDCluster;
  iasZone?: IasZoneCluster;
  identify?: IdentifyCluster;
  illuminanceLevelSensing?: IlluminanceLevelSensingCluster;
  illuminanceMeasurement?: IlluminanceMeasurementCluster;
  levelControl?: LevelControlCluster;
  metering?: MeteringCluster;
  multistateInput?: MultistateInputCluster;
  multistateOutput?: MultistateOutputCluster;
  multistateValue?: MultistateValueCluster;
  occupancySensing?: OccupancySensingCluster;
  onOff?: OnOffCluster;
  onOffSwitch?: OnOffSwitchCluster;
  ota?: OtaCluster;
  pollControl?: PollControlCluster;
  powerConfiguration?: PowerConfigurationCluster;
  powerProfile?: PowerProfileCluster;
  pressureMeasurement?: PressureMeasurementCluster;
  pumpConfigurationAndControl?: PumpConfigurationAndControlCluster;
  relativeHumidity?: RelativeHumidityCluster;
  scenes?: ScenesCluster;
  shadeConfiguration?: ShadeConfigurationCluster;
  temperatureMeasurement?: TemperatureMeasurementCluster;
  thermostat?: ThermostatCluster;
  time?: TimeCluster;
  touchlink?: TouchlinkCluster;
  windowCovering?: WindowCoveringCluster;
}

export type ZCLNodeEndpoint = {
  clusters: ClusterRegistry & {
    [clusterName: string]: ZCLNodeCluster | undefined;
  };
};

export interface ZCLNode {
  endpoints: { [endpointId: number | string]: ZCLNodeEndpoint };
  handleFrame: (
    endpointId: number,
    clusterId: number,
    frame: Buffer,
    meta?: unknown
  ) => Promise<void>;
}

declare module "zigbee-clusters" {
  export const ZCLNode: {
    new (options: ConstructorOptions): ZCLNode;
  };
  export const CLUSTER: {
    [key: string]: { ID: number; NAME: string; ATTRIBUTES: unknown; COMMANDS: unknown };
  };
  export { ZCLNodeCluster };
  export const AlarmsCluster: AlarmsCluster;
  export const AnalogInputCluster: AnalogInputCluster;
  export const AnalogOutputCluster: AnalogOutputCluster;
  export const AnalogValueCluster: AnalogValueCluster;
  export const BallastConfigurationCluster: BallastConfigurationCluster;
  export const BasicCluster: BasicCluster;
  export const BinaryInputCluster: BinaryInputCluster;
  export const BinaryOutputCluster: BinaryOutputCluster;
  export const BinaryValueCluster: BinaryValueCluster;
  export const ColorControlCluster: ColorControlCluster;
  export const DehumidificationControlCluster: DehumidificationControlCluster;
  export const DeviceTemperatureCluster: DeviceTemperatureCluster;
  export const DiagnosticsCluster: DiagnosticsCluster;
  export const DoorLockCluster: DoorLockCluster;
  export const ElectricalMeasurementCluster: ElectricalMeasurementCluster;
  export const FanControlCluster: FanControlCluster;
  export const FlowMeasurementCluster: FlowMeasurementCluster;
  export const GroupsCluster: GroupsCluster;
  export const IasACECluster: IasACECluster;
  export const IasWDCluster: IasWDCluster;
  export const IasZoneCluster: IasZoneCluster;
  export const IdentifyCluster: IdentifyCluster;
  export const IlluminanceLevelSensingCluster: IlluminanceLevelSensingCluster;
  export const IlluminanceMeasurementCluster: IlluminanceMeasurementCluster;
  export const LevelControlCluster: LevelControlCluster;
  export const MeteringCluster: MeteringCluster;
  export const MultistateInputCluster: MultistateInputCluster;
  export const MultistateOutputCluster: MultistateOutputCluster;
  export const MultistateValueCluster: MultistateValueCluster;
  export const OccupancySensingCluster: OccupancySensingCluster;
  export const OnOffCluster: OnOffCluster;
  export const OnOffSwitchCluster: OnOffSwitchCluster;
  export const OtaCluster: OtaCluster;
  export const PollControlCluster: PollControlCluster;
  export const PowerConfigurationCluster: PowerConfigurationCluster;
  export const PowerProfileCluster: PowerProfileCluster;
  export const PressureMeasurementCluster: PressureMeasurementCluster;
  export const PumpConfigurationAndControlCluster: PumpConfigurationAndControlCluster;
  export const RelativeHumidityCluster: RelativeHumidityCluster;
  export const ScenesCluster: ScenesCluster;
  export const ShadeConfigurationCluster: ShadeConfigurationCluster;
  export const TemperatureMeasurementCluster: TemperatureMeasurementCluster;
  export const ThermostatCluster: ThermostatCluster;
  export const TimeCluster: TimeCluster;
  export const TouchlinkCluster: TouchlinkCluster;
  export const WindowCoveringCluster: WindowCoveringCluster;
}

export { ZCLNode, ZCLNodeCluster, ZCLNodeEndpoint, ClusterRegistry };